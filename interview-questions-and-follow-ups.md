## JAVA

### final、finally、finalize的区别

- final可以用来修饰类，方法和变量（成员变量或局部变量）
- finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。
    但是并不是一定会执行，情况可能有：
    1. finally之前调用了`System.exit (0)` 语句，终止了 Java 虚拟机的运行
    2. 在try或catch中被打断（interrupted）或者被终止（killed）
    3. 突然死机或断电



finalize是java.lang.object中定义的，也就是说每个对象都有这个方法，但是一般情况下GC可以回收对象，特殊情况下需要程序员实现这个函数，比如关闭一个socket链接

## 计算机系统

### 从代码到机器码的各个阶段

以C语言为例，C语言编译主要分为四个阶段

1. 预处理

    此阶段**主要完成#符号后面的各项内容到源文件的替换**，往往一些莫名其妙的错误都是出现在头文件中的，要在工程中注意积累一些错误知识。

    - #ifdef等内容，完成条件编译内容的替换
    - #include中内容，在当前目录或者指定目录，或者默认目录搜索头文件，并将头文件拷贝到源文件中。
    - #define的内容，替换define的内容（包括上一步的头文件中的define内容）

    此阶段产生`[.i]`文件。

2.编译

 此阶段**完成语法和语义分析，然后生成中间代码**，此中间代码是汇编代码，但是还不可执行，`gcc`编译的中间文件是[.s]文件。

 在此阶段会出现各种语法和语义错误，特别要小心未定义的行为，这往往是致命的错误。

 第一个阶段和第二个阶段由**编译器**完成。

3.汇编

 此阶段**主要完成将汇编代码翻译成机器码指令，并将这些指令打包形成可重定位的目标文件**，[.O]文件，是二进制文件。

 此阶段由**汇编器**完成。

4.链接

 此阶段**完成文件中调用的各种函数跟静态库和动态库的连接，并将它们一起打包合并形成目标文件，即可执行文件**。

 此阶段由**链接器**完成。

 `gcc`编译C语言主要用到以下几个程序：C编译器`gcc`、汇编器as、链接器`ld`和二进制转换工具`objcopy`。

### 并发并行

### 同步异步

### 阻塞非阻塞

-----

## 计算机网络

### TCP

#### TIME_WAIT出现在哪个阶段，并发量大的情况下TIME_WAIT同时大量存在有什么措施？

① 出现在主动关闭连接方的最后一个阶段，在收到对方的FIN码以及自己发送ACK码后。TIME_WAIT大量存在造成端口号不足使得建立其他新连接失败。

②措施: 

​	 第一是降低TIME_WAIT的等待时间

​	第二是设置处于TIME_WAIT的端口可重用

具体分析参考:https://blog.csdn.net/zl1zl2zl3/article/details/107676367

#### 如果两边同时关闭连接会怎么样，状态怎么变？

- 正常情况下，当客户端发送FIN报文后，应该会先收到(或同时收到)对方的ACK报文，再收到对方的FIN报文。但是如果两边同时关闭连接则会先收到对方的FIN报文
- 此时客户端会由FIN_WAIT_1状态直接进入CLOSING状态

### IP

#### `ip`可以对应多个域名吗，一个域名可以对应多个`ip`吗?

1. 一个域名在同一时刻只能对应一个IP地址

    在域名服务商处，可以把服务器群里面的多个提供相同服务的服务器IP设置一个域名进行轮询。但是同一时刻，一个域名只能解析出一个IP供你使用。这些IP可以轮流着被解析，这些IP对应的服务器提供的是同一种的服务

2. 一个IP可以绑定无数个域名，这个没有限制

------

## 操作系统

### 内存

#### 说说操作系统中程序的内存结构

![img](../mdPics/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153)

一个程序本质上都是由BSS段、data段、text段三个部分组成。可以看到一个可执行程序在存储(没有调入内存)时分为了代码区、数据区和未初始化数据区三个部分

- BSS(未初始化数据区)：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域；BSS属于静态分配内存，程序结束后静态变量由系统自动释放
- 数据段：存放程序中已初始化的全局变量的一块内存区域；数据区也属于静态内存分配
- 代码段：存放程序执行代码的一段内存区域；这部分区域的大小在运行前就已经确定，并且该内存区域为只读区域；在代码段中也有可能包含一些只读的常数变量

关于三个区域区别和联系

- text段和和data段在编译时已经分配了空间，而BSS段并不占可执行文件的大小，它是由链接器来获取内存的
- BSS段(未进行初始化的数据)的内容并不存放在磁盘上的程序文件中，其原因是内核在程序开始运行前将它们设置为0；需要存放在程序文件中的只有正文段和初始化数据段
- data段(已经初始化的数据)则为数据分配空间，数据保存到目标文件中
- 数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区

可执行程序在运行时又多出两个区域：栈区和堆区

- 栈区
    1. 由编译器自动释放，存放函数的参数值、局部变量等
    2. 每当一个函数被调用时，该函数的返回类型和一些调用信息被保存到栈中；然后被调用函数再为其使用到的变量在栈上分配空间
    3. 每调用一个函数一个新的栈就会被使用
    4. 栈区是从高地址向低地址增长的，是一块连续的内存区域，最大容量由系统预先定义好，申请的栈空间超过临界值时会提示溢出，用户能从栈中获取的空间较小
- 堆区
    1. 用于动态分配内存，位于BSS和栈中间的地址区域
    2. 由程序员申请分配和释放
    3. 堆是由低地址向高地址位增长，采用链式存储结构；
    4. 频繁的malloc/free会造成内存空间的不连续，即碎片化；当申请堆空间是系统按照一定的算法搜索足够大的空间，因此堆的效率比栈要低

-----

### 进程

#### copy-on-write

写入时复制（英语：Copy-on-write，简称COW）是一种计算机[程序设计](https://wikipedia.hk.wjbk.site/baike-程式設計)领域的优化策略。其核心思想是: 如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源

#### 为什么进程进行上下文切换比线程上下文切换代价高？

进程切换分两步：

- 切换页目录以使用新的地址空间

- 切换内核栈和硬件上下文

    对于`linux`来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

切换的性能消耗：

- 线程上下文切换和进程上下文切换一个最主要的区别是**线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的**。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。
- 另外一个隐藏的损耗是**上下文的切换会扰乱处理器的缓存机制**。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题

#### 多进程和多线程的区别和选择

[多进程和多线程的区别和选择](https://blog.csdn.net/yu876876/article/details/82810178)

----

## Linux

### linux查看进程怎么看？

- ps: 查看某个时间点的进程信息

    > ​	ps -l : 进查看自己的bash相关进程
    >
    > ​	ps aux: 查看系统所有进程

- top: 动态查看进程的变化
- pstree: 查看进程树

参考：《鸟哥私房菜》p524

-----

## `mysql`

### `mysql`如何解除死锁

```mysql
解除正在死锁的状态有两种方法：

第一种：
	1.查询是否锁表
	  show OPEN TABLES where In_use > 0;
	2.查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）
	  show processlist
	3.杀死进程id（就是上面命令的id列）
	  kill id
	  
第二种：
	1.查看下在锁的事务 
	  SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
	2.杀死进程id（就是上面命令的trx_mysql_thread_id列）
	  kill 线程ID

其它关于查看死锁的命令：
    1：查看当前的事务
      SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;

    2：查看当前锁定的事务
      SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;

    3：查看当前等锁的事务
      SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
```

### `mysql innodb主键为什么最好是自增的`

[innodb选用自增数字作为主键的原因](https://www.cnblogs.com/kancy/p/13458991.html)

### 1000万个数据的B+树有多高

1. 首先每个`innoDB`的页的大小为16KB，如果主键为`int`类型就是4字节，同时指向下一节点的指针也会占用6字节；如果主键为`bigInt`型，占用的长度为8字节 16k/14 = 1170，则一层的节点个数为1170.
2. 同时可以计算叶子结点存放的数据的个数：如果一条数据为1kb，则可以存放16条数据
3. 一颗高度为2的B+树可以存放 1170*16条数据
4. 一颗高度为3的B+树可以存放 1170*1170*16 =2000w条数据
5. 所以b+树的高度一般为1～3层

### 主从复制`binlog延`迟太多怎么办



-----

## `kafka`

### `kafka`选主是怎么做的

- 参考：https://www.cnblogs.com/tonggc1668/p/12051030.html

### `kafka`为什么吞吐量高，速度快？

- [答案](https://blog.csdn.net/kzadmxz/article/details/101576401)
- [kafka是如何实现高性能的](https://zhuanlan.zhihu.com/p/106033054)

-----

## 一些系统设计的题目

### 单点登录

[SSO](https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86)

### 排行榜设计

[排行榜的简单设计思路](https://www.cnblogs.com/leestar54/p/13200549.html)

------

## 设计模式

### 单例模式

#### 1、使用`synchronized`实现的双重验证懒汉模式

```java
public class  Singleton {
    private static volatile Singleton singleton = null;
    
    private Singleton(){}
    
    public static Singleton getInstance() {
        if(singleton == null) {
            synchronized(Singleton.class) {
                if(singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

#### 2、使用`ReentrantLock`实现的双重验证懒汉模式

```java
public class Singleton {
    private static final Lock lock = new ReentrantLock();
    private static volatile Singleton singleton = null;
    
    private Singleton(){}
    
    public static Singleton getInstance() {
        if(singleton == null) {
            lock.lock();
            try {
                if(singleton == null) {
                    singleton = new Singleton();
                }
            } finally {
                lock.unlock();
            }
        }
        return singleton;
    }
}
```

#### 3、不使用锁的单例

[不使用锁实现单例](https://blog.csdn.net/minkeyto/article/details/104799888)